#!/usr/bin/env lua
--[[
 * A lua library to translate from /etc/config/wireless into
 * MediaTek's WiFi profile (mt76xx.dat) and vice-versa.
 *
 * Copyright (C) 2018 Hua Shao <nossiac@163.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 2.1
 * as published by the Free Software Foundation
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
]]

package.path = '../?.lua;'..package.path

local uci = require("shuci")
local l1profile = "/etc/wireless/l1profile.dat"
local ucifile = "/etc/config/wireless"

local SKU_REGION_NORMAL = {
    ["CN"] = {
        ["region"]      = "1",
        ["aregion"]     = "0",
        ["SKUenable"]   = "0"
    },
    ["EU"] = {
        ["region"]      = "1",
        ["aregion"]     = "1",
        ["SKUenable"]   = "1"
    },
    ["UK"] = {
        ["region"]      = "1",
        ["aregion"]     = "1",
        ["SKUenable"]   = "1"
    },
    ["JP"] = {
        ["region"]      = "1",
        ["aregion"]     = "6",
        ["SKUenable"]   = "0"
    },
    ["KR"] = {
        ["region"]      = "1",
        ["aregion"]     = "10",
        ["SKUenable"]   = "0"
    },
    ["US"] = {
        ["region"]      = "0",
        ["aregion"]     = "7",
        ["SKUenable"]   = "0"
    },
    ["ID"] = {
        ["region"]      = "1",
        ["aregion"]     = "1",
        ["SKUenable"]   = "0"
    },
    ["IN"] = {
        ["region"]      = "1",
        ["aregion"]     = "10",
        ["SKUenable"]   = "0"
    }
}

function find_sku_info(sku, table_info)
    for k, v in pairs(table_info) do
        if k == sku then
            return v
        end
    end
    return nil
end

-- this flag is used in uci2dat and dat2uci
-- if set to true, the tool will NOT actually modify the target file,
-- but dump the result to stdout
local testmode = false

-- this flag is used in datdiff
-- if false, will dump diff result in plain text
-- if true, will generate "iwpriv" commands according to diff result
local iwpriv_mode = false

function __trim(s)
  if s then return (s:gsub("^%s*(.-)%s*$", "%1")) end
end


-- lua sorted pairs
function __spairs(t, order)
    local keys = {}
    for k in pairs(t) do keys[#keys+1] = k end
    table.sort(keys, order)

    -- return a closure as an iterator
    local i = 0
    return function()
        i = i + 1
        if keys[i] then
            return keys[i], t[keys[i]]
        end
    end
end

function string:split(sep)
    local sep, fields = sep or ":", {}
    local pattern = string.format("([^%s]+)", sep)
    self:gsub(pattern, function(c) fields[#fields+1] = c end)
    return fields
end

-- load MediaTek WiFi profile as a lua table
function load_profile(path)
    local cfgs = {}
    local fd = io.open(path, "r")
    if not fd then return cfgs end

    for line in fd:lines() do
        line = __trim(line)
        if string.byte(line) ~= string.byte("#") then
            local i = string.find(line, "=")
            if i then
                local k,v
                k = string.sub(line, 1, i-1)
                v = string.sub(line, i+1)
                -- if cfgs[__trim(k)] then
                --     print("warning", "skip repeated key"..line)
                -- end
                cfgs[__trim(k)] = __trim(v) or ""
            -- else
            --     print("warning", "skip line without '=' "..line)
            end
        -- else
        --     print("warning", "skip comment line "..line)
        end
    end
    fd:close()
    return cfgs
end


-- save configuration table as MediaTek wifi profile
function save_profile(cfgs, path)
    local fd = io.stdout
    if path then fd = io.open(path, "w") end

    fd:write("# Generated by uci2dat\n")
    fd:write("Default\n")
    for k,v in __spairs(cfgs) do
        fd:write(k.."="..v.."\n")
    end
    fd:close()
end


function merge_profile(t1, t2)
    if not t1 or not t2 or not next(t2) then return end
    for k,v in pairs(t2) do
        t1[k] = v
    end
end

function vifs_cfg_param(param)
    local vifs_cfg_params = {"Auth", "EncrypType", "Key", "WPAPSK", ";", "HT_BW", "VHT_BW", "HT_BSSCoexistence"}
	for _, pat in ipairs(vifs_cfg_params) do
        if string.find(param, pat) then
            return true
        end
    end
	return false
end


function get_vifs_by_dev(ucicfg, devname)
    local vifs = {}
    for vifname, vif in pairs(ucicfg["wifi-iface"]) do
        if vif.device == devname then
            if tonumber(vif.vifidx) then
                vifs[#vifs +1] = vif
            end
        end
    end

    table.sort(vifs, function(a , b)
        return tostring(a.vifidx) < tostring(b.vifidx)
    end)

    for vifname, vif in pairs(ucicfg["wifi-iface"]) do
        if vif.device == devname then
            if tonumber(vif.vifidx) == nil  then
                vifs[#vifs+1] = vif
            end
        end
    end

    return vifs
end

function get_wlan_macaddr(ifname)
    local rsfile = io.popen('getmac '..ifname)
    local macaddr = rsfile:read("*all")
    --print("macaddr: "..macaddr)
    --print(#macaddr)
    --print(string.len(macaddr))
    rsfile:close()
    if (#macaddr >= 17) then
        macaddr = string.sub(macaddr, 1, 17)
        ---- TODO: NEED check mac vaild
        if (macaddr == "ff:ff:ff:ff:ff:ff") or (macaddr == "00:00:00:00:00:00") then
            print("invalid mac so return err")
            return "err"
        else
        --print("return OK")
        return macaddr
        end
    else
        print("invalid mac so return err")
        return "err"
    end
end

function vif_cfg_ssid(vifs)
    assert(vifs)
    assert(type(vifs) == "table")

    local t = {}
    local macaddr = string

    t["BssidNum"] = #vifs
    for i,vif in ipairs(vifs) do
        if vif.mode == "ap" then
            t["SSID"..tostring(i)] = vif.ssid
        elseif vif.mode == "sta" then
            t["ApCliSsid"] = vif.ssid
            t["BssidNum"] = t["BssidNum"] - 1
        end
        vif.ssid = nil
    end
    for i,vif in ipairs(vifs) do
        if vif.mode == "ap" then
            t["IFNAME"..tostring(i)] = vif.ifname
            if i == 1 then
                macaddr = get_wlan_macaddr(vif.ifname)
                if macaddr == "err" then
                else
                    t["MacAddress"] = macaddr
                end
            end
        end
        vif.ifname = nil
    end
    return t
end

function vif_cfg_wds(vifs)
    assert(vifs)
    assert(type(vifs) == "table")

    local t = {}
    local ap_wds = ""

    for i, vif in ipairs(vifs) do
        repeat
            if vif.mode == "ap" then
                if vif.wds and tonumber(vif.wds) == 1 then
                    ap_wds = ap_wds.."1"
                else
                    ap_wds = ap_wds.."0"
                end

                if i < #vifs then
                    ap_wds = ap_wds..";"
                end

                t["ApMWDS"] = ap_wds
                vif.wds = nil
            elseif vif.mode == "sta" then
                t["ApCliMWDS"] = vif.wds or '0'
                vif.wds = nil
            end

        until true

    end

    return t
end

function vif_cfg_bsd(vifs)
    assert(vifs)
    assert(type(vifs) == "table")

    local t = {}

    for i, vif in ipairs(vifs) do
        repeat
            if vif.device ~= "MT7622_1" then
                if vif.bsd then
                    vif.bsd = nil
                end
                break
            elseif vif.bsd then
                t["bsd"] = vif.bsd
                vif.bsd = nil
            end
        until true
    end

    return t
end

function vif_cfg_ap_bh(vifs)
    assert(vifs)
    assert(type(vifs) == "table")

    local uci_r = require "uci".cursor()
    local backhaul = ""
    local t = {}

    for i,vif in ipairs(vifs) do
        for k, v in pairs(vif) do
            if k == ".name" and (v == "backhaul_5g" or v == "bh_ap") then
                local aplimit = uci_r:get("wireless", v, "mesh_aplimit")
                local apmac = uci_r:get("wireless", v, "mesh_apmac")
                local meshid = uci_r:get("wireless", v, "mesh_id")

                if aplimit ~= nil  then
                    t["mesh_aplimit"] = aplimit
                    vif.mesh_aplimit = nil
                end

                if apmac ~= nil then
                    t["mesh_apmac"] = apmac
                    vif.mesh_apmac = nil
                end

                if meshid ~= nil then
                    t["mesh_id"] = meshid
                    vif.mesh_id = nil
                end
            end
        end

        -- check backhaul cfg
        repeat
            if vif.mode == "ap" then
                if vif.backhaul and tonumber(vif.backhaul) == 1 then
                    backhaul = backhaul.."1"
                else
                    backhaul = backhaul.."0"
                end

                if i < #vifs then
                    backhaul = backhaul..";"
                end

                t["backhaul"] = backhaul
                vif.backhaul = nil
            end

        until true
    end

    return t
end

function key_to_table(key)
    local t = {}
    if key and key ~="" then
        t = key:split(";")
    end

    return t
end

function dat2uci_vif_cfg_encryption(auth,encr)
    if auth == "OPEN" and encr == "NONE" then
        encr = "none"
    elseif auth == "OPEN" and encr == "WEP" then
        encr = "wep-open"
    elseif auth == "SHARED" and encr == "WEP" then
        encr = "wep-shared"
    elseif auth == "WPAPSK" and encr == "AES" then
        encr = "psk"
    elseif auth == "WPAPSK" and encr == "TKIP" then
        encr = "psk+tkip"
    elseif auth == "WPAPSK" and encr == "TKIPAES" then
        encr = "psk+tkip+ccmp"
    elseif auth == "WPA2PSK" and encr == "AES" then
        encr = "psk2"
    elseif auth == "WPA2PSK" and encr == "TKIP" then
        encr = "psk2+tkip"
    elseif auth == "WPA2PSK" and encr == "TKIPAES" then
        encr = "psk2+tkip+ccmp"
    elseif auth == "WPAPSKWPA2PSK" and encr == "AES" then
        encr = "mixed-psk"
    elseif auth == "WPAPSKWPA2PSK" and encr == "TKIP" then
        encr = "psk-mixed+tkip"
    elseif auth == "WPAPSKWPA2PSK" and encr == "TKIPAES" then
        encr = "psk-mixed+tkip+ccmp"
    elseif auth == "WPA" and encr == "AES" then
        encr = "wpa"
    elseif auth == "WPA2" and encr == "AES" then
        encr = "wpa2"
    elseif auth == "WPA1WPA2" and encr == "AES" then
        encr = "wpa+wpa2"
    elseif auth == "WPA3" and encr == "AES" then
        encr = "ccmp"
    else -- default, open
        encr = "none"
    end
    return encr
end

function vif_cfg_encryption(vifs)
    assert(vifs)
    assert(type(vifs) == "table")

    local t = {}
    local auth = ""
    local encr = ""
    local apcli_auth = ""
    local apcli_encr = ""
    local auth_server = ""
    local auth_port = ""
    local auth_secret = ""
    local pmfmfpc = ""
    local pmfmfpr = ""
    local pmfsha256 = ""

    for i, vif in ipairs(vifs) do
        if vif.mode == "ap" then
            if vif.encryption == "none" then
                auth = auth.."OPEN"
                encr = encr.."NONE"
            elseif vif.encryption == "mixed-psk" then --wpa+wpa2  PSK
                auth = auth.."WPAPSKWPA2PSK"
                encr = encr.."TKIPAES"
            elseif vif.encryption == "psk2" then    -- WPA2 PSK
                auth = auth.."WPA2PSK"
                encr = encr.."AES"
            elseif vif.encryption == "psk2+ccmp" then   -- WPA2+WAP3 PSK
                auth = auth.."WPA2PSKWPA3PSK"
                encr = encr.."AES"
            elseif vif.encryption == "ccmp" then    -- WPA3 PSK
                auth = auth.."WPA3PSK"
                encr = encr.."AES"
            elseif vif.encryption == "wpapsk-mix" then    -- wpapsk-mix
                auth = auth.."WPAPSK"
                encr = encr.."TKIPAES"
            elseif vif.encryption == "wep-open" then    -- wep open
                auth = auth.."OPEN"
                encr = encr.."WEP"
            elseif vif.encryption == "wep-shared" then    -- wep shared
                auth = auth.."SHARED"
                encr = encr.."WEP"
            else -- TODO: just suport PSK (WPA/WPA2 WPA2 WPA2/WPA3 WPA4) and OPEN
                auth = auth.."OPEN"
                encr = encr.."NONE"
            end
            

            if vif.auth_server == nil then
                vif.auth_server='0'
            end
            if vif.auth_port == nil then
                vif.auth_port='0'
            end
            auth_server = auth_server..vif.auth_server
            auth_port = auth_port..vif.auth_port

            if vif.ieee80211w == nil then
                vif.ieee80211w = '0'
            end

            if vif.ieee80211w == "1" then
                pmfmfpc = pmfmfpc..'1'
                pmfmfpr = pmfmfpr..'0'
                pmfsha256 = pmfsha256..'1'
            elseif vif.ieee80211w == "2" then
                pmfmfpc = pmfmfpc..'1'
                pmfmfpr = pmfmfpr..'1'
                pmfsha256 = pmfsha256..'1'
            else
                pmfmfpc = pmfmfpc..'0'
                pmfmfpr = pmfmfpr..'0'
                pmfsha256 = pmfsha256..'0'
            end
            
            -- don't forget the delimiter ";"
            if i<#vifs then
                auth = auth..";"
                encr = encr..";"
                -- for wpa*
                auth_server = auth_server..";"
                auth_port = auth_port..";"

                pmfmfpr = pmfmfpr..";"
                pmfsha256 = pmfsha256..";"
            end

            t["AuthMode"] = auth
            t["EncrypType"] = encr

            t["RADIUS_Server"] = auth_server
            t["RADIUS_Port"] = auth_port
            t["RADIUS_Key"..tostring(i)] = vif.auth_secret or auth_secret

            t["PMFMFPC"] = pmfmfpc
            t["PMFMFPR"] = pmfmfpr
            t["PMFSHA256"] = pmfsha256

            -- WEP keys
            t["Key"..tostring(i).."Type"] = "1" -- 0=hex, 1=string
            if vif.key1 ~= nil and (#vif.key1 == 7 or #vif.key1 == 15) then
                vif.key1 = string.sub(vif.key1,3)
            end
            t["Key1Str"..tostring(i)] = vif.key1
            t["Key2Str"..tostring(i)] = vif.key2
            t["Key3Str"..tostring(i)] = vif.key3
            t["Key4Str"..tostring(i)] = vif.key4
            t["DefaultKeyID"] = 0

            -- PSK keys
            if vif.sae_password ~= nil then
                t["WPAPSK"..tostring(i)] = vif.sae_password
            else
                t["WPAPSK"..tostring(i)] = vif.key
            end

            -- unset keys already done
            vif.key = nil
            vif.key1 = nil
            vif.key2 = nil
            vif.key3 = nil
            vif.key4 = nil
            vif.auth_secret = nil
            vif.encryption = nil
            vif.sae = nil
            vif.sae_password = nil
            vif.ieee80211w = nil

        elseif vif.mode == "sta" then
            if vif.encryption == "none" then
                apcli_auth = "OPEN"
                apcli_encr = "NONE"
            elseif vif.encryption == "mixed-psk" then --wpa+wpa2  PSK
                apcli_auth = "WPAPSKWPA2PSK"
                apcli_encr = "TKIPAES"
            elseif vif.encryption == "psk2" then    -- WPA2 PSK
                apcli_auth = "WPA2PSK"
                apcli_encr = "AES"
            elseif vif.encryption == "psk2+ccmp" then   -- WPA2+WAP3 PSK
                apcli_auth = "WPA2PSKWPA3PSK"
                apcli_encr = "AES"
            elseif vif.encryption == "ccmp" then    -- WPA3 PSK
                apcli_auth = "WPA3PSK"
                apcli_encr = "AES"
            elseif vif.encryption == "wpapsk-mix" then    -- wpapsk-mix
                apcli_auth = "WPAPSK"
                apcli_encr = "TKIPAES"
            elseif vif.encryption == "WPAPSK" then --old uci WPA PSK
                apcli_auth = "WPAPSK"
                apcli_encr = "AES"
            elseif vif.encryption == "WPA2PSK" then --old uci WPA2 PSK
                apcli_auth = "WPA2PSK"
                apcli_encr = "AES"
            elseif vif.encryption == "WPA3PSK" then --old uci WPA3 PSK
                apcli_auth = "WPA3PSK"
                apcli_encr = "AES"
            else -- TODO: just suport PSK (WPA/WPA2 WPA2 WPA2/WPA3 WPA3) and OPEN
                apcli_auth = "OPEN"
                apcli_encr = "NONE"
            end

            t["ApCliEnable"] = 1
            t["ApCliAuthMode"] = apcli_auth
            t["ApCliEncrypType"] = apcli_encr
            t["ApCliWPAPSK"] = vif.key

            -- unset keys already done
            vif.key = nil
            vif.key1 = nil
            vif.key2 = nil
            vif.key3 = nil
            vif.key4 = nil
            vif.auth_secret = nil
            vif.encryption = nil
        end
    end

    return t
end


--[[
    Traslate ucikey into datkey by vifs (per SSID)

    vifs:      wifi interfaces(per SSID)
    ucikey:    the keyword defined in uci config
    datkey:    coresponding keyword in dat, optional.
    default:   default value if key is not specified
]]

function vif_cfg_by_key(vifs, ucikey, datkey, default)
    local t = {}

    local key = datkey
    local strbuf = ""
    if not key then key = ucikey end
    if not default then default = 0 end

    for i,vif in ipairs(vifs) do
        if type(vif[ucikey]) == "string" or type(vif[ucikey]) == "number" then
            strbuf = strbuf..tostring(vif[ucikey])
        else
            strbuf = strbuf..tostring(default)
        end
        -- don't forget the delimiter ";"
        if i<#vifs then strbuf = strbuf..";" end

        -- unset keys already done
        vif[ucikey] = nil
    end

    t[key] = strbuf

    return t
end

function wmm_edca_parm(ucikey)
    local parms = {"Aifsn", "Cwmax", "Cwmin", "Txop"}
    for _, pat in ipairs(parms) do
        if string.find(ucikey, pat) then
            return true
        end
    end
    return false
end

function vif_cfg_ignore(vifs, ucikey)
    if type(ucikey) == "string" then
        for i,vif in ipairs(vifs) do
            vif[ucikey] = nil
        end
    elseif type(ucikey) == "table" then
        for _,key in ipairs(ucikey) do
            for i,vif in ipairs(vifs) do
                vif[key] = nil
            end
        end
    end
end


function vif_cfg_all(vifs)
    if #vifs < 1 then return end
    local t = {}

    local keys = {}
    for _,vif in pairs(vifs) do
        for k,_ in pairs(vif) do
            keys[k] = true
        end
    end

    for k,_ in pairs(keys) do
        local strbuf = ""
        for i=1, #vifs do
            v = vifs[i][k]
            if type(v) == "string" or type(v) == "number" then
                strbuf = strbuf..tostring(v)
            else
                strbuf = strbuf..tostring(0)
            end
            -- don't forget the delimiter ";"
            if i<#vifs then strbuf = strbuf..";" end

            -- unset keys already done
            vifs[i][k] = nil
        end
        t[k] = strbuf
    end

    return t
end

function load_l1profile(path, dump)
    local l1dat = {}
    local fd = io.open(path, "rb")
    if not fd then error("failed to open "..path) return end
    for line in fd:lines() do
        local m,n,i,devname = string.find(line, "INDEX(%d)=([^%s\'\"]+)")
        if i and devname then
            local devidx = 1
            for i,dev in ipairs(l1dat) do
                if dev.chipname == devname then
                    devidx = devidx + 1
                end
            end
            l1dat[tonumber(i)+1] = {}
            l1dat[tonumber(i)+1]["chipname"] = devname
            l1dat[tonumber(i)+1]["devname"] = devname.."."..tostring(devidx)
        end
        local m,n,i,k,v = string.find(line, "INDEX(%d)_([%w-_]+)=([^%s\'\"]*)")
        if i and k then
            -- print(i,k,v)
            l1dat[tonumber(i)+1][k] = v
        end
    end
    fd:close()
	
    -- split dbdc dev into 2 devs
    local idx = 1
    local dbdc = {}
    for i,dev in ipairs(l1dat) do
            if dev.profile_path:find(";") then
                    -- make a dup first
                    dbdc[idx] = {}
                    for k,v in pairs(dev) do
                            if v:find(";") then
                                    local v1v2 = v:split(";")
                                    assert(2 == #v1v2)
                                    l1dat[i][k] = v1v2[1]
                                    dbdc[idx][k] = v1v2[2]
                            else
                                    dbdc[idx][k] = v
                            end
                    end
                    dbdc[idx]["devname"] = l1dat[i].devname..".2"
                    l1dat[i]["devname"] = l1dat[i].devname..".1"
                    idx = idx + 1
            end
    end

    local idx = #l1dat + 1
    for _,dev in ipairs(dbdc) do
            l1dat[idx] = {}
            for k,v in pairs(dev) do
                    l1dat[idx][k] = v
            end
            idx = idx + 1
    end


    if dump then
        for i,dev in ipairs(l1dat) do
            for k,v in pairs(dev) do
                print(string.format("l1dat[%d].%s=%s", i, k, v))
            end
        end
    end

    return l1dat
end

function vif_cfg_maclist(vifs)
    assert(vifs)
    assert(type(vifs) == "table")

    local t = {}
    --local key = datkey
    --if not key then key = ucikey end

    for i, vif in ipairs(vifs) do
        -- mesh_ver3/mesh_ver4 and later version only store backhaul macfilter rules in uci, not put into effect
        for k, v in pairs(vif) do
            if k == ".name" and (v == "backhaul_5g" or v == "bh_ap") then
                vif["macfilter"] = nil
                vif["maclist"] = nil
                break
            end
        end

        t["AccessPolicy"..tostring(i-1)] = 0
        t["AccessControlList"..tostring(i-1)] = ""
        if vif["macfilter"] == "deny" then
            t["AccessPolicy"..tostring(i-1)] = 2
        elseif vif["macfilter"] == "allow" then
            t["AccessPolicy"..tostring(i-1)] = 1
        end
        vif["macfilter"] = nil
        --print("@@@AccessPolicy"..tostring(i-1).."="..t["AccessPolicy"..tostring(i-1)])

        if vif["maclist"] then
            --print("@@@ vif[maclist] type:"..type(vif["maclist"]))
            if type(vif["maclist"]) == "string" and vif["maclist"] == "" then
                break
            end
            local strbuf = ""
            for  k, v in ipairs(vif["maclist"]) do
                --print("@@@k="..k.." V="..v)

                strbuf = strbuf..tostring(v)
                --print("@@@strbuf="..strbuf)
                -- don't forget the delimiter ";"
                if k<#vif["maclist"] then strbuf = strbuf..";" end
            end
            --vif[ucikey] = strbuf
            t["AccessControlList"..tostring(i-1)] = strbuf
            --print("@@@"..key..tostring(i-1))
        end
        --print("@@@AccessControlList"..tostring(i-1).."="..t["AccessControlList"..tostring(i-1)])
        --t[key..tostring(i-1)] = vif[ucikey]

        vif["maclist"] = nil
    end

    return t
end

function merge_ssid_and_key(uci, vifs)
    for k,v in pairs(uci) do
        if type(v) == "table" then
            if v.ifname ~= nil then
                for i, vif in ipairs(vifs) do
                    if v.ifname == vif.ifname then
                        if v.sae_password and vif.sae_password then
                            vif.sae_password = v.sae_password
                        end
                        if v.key and vif.key then
                            vif.key = v.key
                        end
                        if v.ssid and vif.ssid then
                            vif.ssid = v.ssid
                        end
                    end
                end
            end
        end
    end
end

local UCI = require("luci.model.uci").cursor()

function uci2dat(ucifile, datfile, devname)
    if not ucifile then error("ucifile not specified!") return end
    if not datfile then error("datfile not specified!") return end
    if not devname then error("devname not specified!") return end
    if devname then devname = devname:gsub("%.", "_") end

    local rsfile = io.popen("bdata get CountryCode")
    local BD_CountryCode = rsfile:read("*all")
    BD_CountryCode = __trim(BD_CountryCode)
    rsfile:close()

    local rsfile = io.popen("nvram get CountryCode")
    local NV_CountryCode = rsfile:read("*all")
    NV_CountryCode = __trim(NV_CountryCode)
    rsfile:close()

    local ucicfg = uci.decode(ucifile)
    if not ucicfg then error("unable to decode "..ucifile) return end

    local wireless_cfg = UCI:get_all("wireless")
    local datcfg = load_profile(datfile)

    for _,dev in pairs(ucicfg["wifi-device"]) do while true do
        --------------- interface level ---------------
        if devname ~= dev.device then break end
        local vifs = get_vifs_by_dev(ucicfg, devname)
        if not vifs or #vifs < 1 then break end
        local vifscfg = {}
        local devscfg = {}
        local t = {}

        merge_ssid_and_key(wireless_cfg, vifs)
        -- special apis to deal with complicated keys
        t = vif_cfg_encryption(vifs)
        merge_profile(vifscfg, t)

        t = vif_cfg_ssid(vifs)
        merge_profile(vifscfg, t)

        t = vif_cfg_maclist(vifs)
        merge_profile(vifscfg, t)

        -- process ap and sta wds cfg
        t = vif_cfg_wds(vifs)
        merge_profile(vifscfg, t)

        t = vif_cfg_bsd(vifs)
        merge_profile(vifscfg, t)

        -- process xiao mesh backhual cfg
        t = vif_cfg_ap_bh(vifs)
        merge_profile(vifscfg, t)

        -- common api to fetch a key
        local vif_cfg_uci2dat = {
                    disabled = "Disabled",
                    wmm = "WmmCapable",
                    hidden = "HideSSID",
                    wifimode = "WirelessMode",
                    IgmpSnEnable ="IgmpSnEnable",
                    ap_isolate = "NoForwarding"
            }

        for ucikey,datkey in pairs(vif_cfg_uci2dat) do
            t = vif_cfg_by_key(vifs, ucikey, datkey)
            merge_profile(vifscfg, t)
        end

        merge_profile(vifscfg, t)
        -- ignore a single key
        t = vif_cfg_ignore(vifs, "device")
        merge_profile(vifscfg, t)

        -- ignore a group of keys
        t = vif_cfg_ignore(vifs, {"mode", "network"})
        merge_profile(vifscfg, t)

        t = vif_cfg_ignore(vifs, {"auth_port", "auth_secret", "auth_server"})
        merge_profile(vifscfg, t)

        -- fetch all rest keys
        t = vif_cfg_all(vifs)
        merge_profile(vifscfg, t)

        -- dump all we've got
        -- for k,v in __spairs(vifscfg) do print(k.."="..v) end

        devscfg.MuOfdmaDlEnable = 0
        devscfg.MuOfdmaUlEnable = 0
        devscfg.TWTSupport = 0
        devscfg.MuMimoDlEnable = 0
        devscfg.MuMimoUlEnable = 0
        devscfg.SRSDEnable = 0  -- BSS color
        devscfg.SREnable = 0    -- BSS color
        devscfg.CountryCode = "CN"  -- default CN
        devscfg.BFBACKOFFenable = 0
        devscfg.SKUenable = 0
        --------------- device level ---------------
        for k,v in pairs(dev) do
            -- Ignore these config, they don't mean anything in MediaTek profile.
            if string.byte(k) == string.byte(".")
            or string.byte(k) == string.byte("_")
            or k == "profile"
            or k == "type"
            or k == "vendor"
            or k == "mode"
            or k == "path" then
                -- ignored

            -- The following keywords are used by openwrt luci ui:
            -- ref: https://wiki.openwrt.org/doc/uci/wireless
            -- We follow its convention.
            elseif k == "channel" then
                if v == "0" then
                    devscfg.AutoChannelSelect = "3"
                else
                    devscfg.AutoChannelSelect = "0"
                end
                devscfg.Channel = v
            elseif k == "disabled" then
                devscfg.BandDisabled = v
            elseif k == "country" then
                devscfg.CountryCode = v
            elseif k == "txpwr" then
                if v == "max" then
                    devscfg.TxPower = 100
                elseif v == "mid" then
                    devscfg.TxPower = 75
                elseif v == "min" then
                    devscfg.TxPower = 50
                end
            elseif k == "ax" then   -- OFDMA, TWT, BSS color
                local uci = require("luci.model.uci").cursor()
                local ifname
                --兼容旧品的逻辑，通过判断wifi5_bk接口的ssid是否存在来区分旧版本和新版本
                local wifi5_bk_exist
                if dev.band == "2G" then
                    ifname = uci:get("misc", "wireless", "wifi5_bk_2G")
                    dlofdma = uci:get("wireless", "MT7981_1_1", "MuOfdmaDlEnable")
                    ulofdma = uci:get("wireless", "MT7981_1_1", "MuOfdmaUlEnable")
                else
                    ifname = uci:get("misc", "wireless", "wifi5_bk_5G")
                    dlofdma = uci:get("wireless", "MT7981_1_2", "MuOfdmaDlEnable")
                    ulofdma = uci:get("wireless", "MT7981_1_2", "MuOfdmaUlEnable")
                end
                if ifname ~= nil then
                    wifi5_bk_exist = uci:get("wireless", ifname, "ssid")
                end
                --如果wifi5接口存在,只配置wifi6，wifi5在mtkwifi.inc启动脚本设置
                if wifi5_bk_exist ~= nil then
                    if dlofdma ~=nil and dlofdma == "0" then
                        devscfg.MuOfdmaDlEnable = 0
                    else
                        devscfg.MuOfdmaDlEnable = 1        
                    end
                    ulofdma = uci:get("wireless", ifname, "MuOfdmaUlEnable")
                    if dlofdma ~=nil and dlofdma == "1" then
                        devscfg.MuOfdmaUlEnable = 1
                    else
                        devscfg.MuOfdmaUlEnable = 0
                    end
                    devscfg.TWTSupport = 0
                    SREnable = uci:get("wireless", ifname, "SREnable")
                    if SREnable ~=nil and SREnable == "0" then              
                        devscfg.SRSDEnable = 0
                        devscfg.SREnable = 0
                    else
                        devscfg.SRSDEnable = 1
                        devscfg.SREnable = 1
                    end
                    if dev.band == "2G" then
                        devscfg.WirelessMode = 16   --11BGN/AX
                        devscfg.VHT_SGI = 0
                    else
                        devscfg.WirelessMode = 17   --11A/AN/AC/AX
                    end
                else
                    --如果wifi5接口不存在走原来版本代码逻辑
                    if v == "0" then
                        devscfg.MuOfdmaDlEnable = 0
                        devscfg.MuOfdmaUlEnable = 0
                        devscfg.TWTSupport = 0
                        devscfg.SRSDEnable = 0
                        devscfg.SREnable = 0
                        if dev.band == "2G" then
                            devscfg.WirelessMode = 9   --11BGN
                            devscfg.VHT_SGI = 0
                        else
                            devscfg.WirelessMode = 14   --11A/AN/AC
                        end
                    else
                        devscfg.MuOfdmaDlEnable = 1
                        devscfg.MuOfdmaUlEnable = 1
                        devscfg.TWTSupport = 0
                        devscfg.SRSDEnable = 1
                        devscfg.SREnable = 1
                        if dev.band == "2G" then
                            devscfg.WirelessMode = 16   --11BGN/AX
                            devscfg.VHT_SGI = 0
                        else
                            devscfg.WirelessMode = 17   --11A/AN/AC/AX
                        end
                    end
                end
            elseif k == "txbf" then     -- MU-MIMO
                if v == "3" then
                    devscfg.MuMimoDlEnable = 1
                    devscfg.MuMimoUlEnable = 0
                    devscfg.MUTxRxEnable = 1
                elseif v == "0" then
                    devscfg.MuMimoDlEnable = 0
                    devscfg.MuMimoUlEnable = 0
                    devscfg.MUTxRxEnable = 0
                elseif v == "1" then
                    devscfg.MuMimoDlEnable = 1
                    devscfg.MuMimoUlEnable = 1
                    devscfg.MUTxRxEnable = 1
                elseif v == "2" then
                    devscfg.MuMimoDlEnable = 0
                    devscfg.MuMimoUlEnable = 1
                    devscfg.MUTxRxEnable = 1
                end
            elseif k == "bgprotect" then
                devscfg.BGProtection = v
            elseif k == "pktaggre" then
                devscfg.PktAggregate = v
            elseif k == "bw" then
                devscfg.HT_BSSCoexistence = 0
                if v == "0" then
                    if dev.band == "2G" then
                        devscfg.HT_BW = 1
                        devscfg.VHT_BW = 0
                        devscfg.HT_BSSCoexistence = 1
                    else
                        devscfg.HT_BW = 1
                        devscfg.VHT_BW = 2
                    end
                elseif v == "20" then
                    devscfg.HT_BW = 0
                    devscfg.VHT_BW = 0
                elseif v == "40" then
                    devscfg.HT_BW = 1
                    devscfg.VHT_BW = 0
                elseif v == "80" then
                    devscfg.HT_BW = 1
                    devscfg.VHT_BW = 1
                elseif v == "160" then
                    devscfg.HT_BW = 1
                    devscfg.VHT_BW = 2
                elseif v == "80+80" then
                    devscfg.HT_BW = 1
                    devscfg.VHT_BW = 3
                end
            elseif wmm_edca_parm(k) then
                devscfg[k] = string.gsub(tostring(v), ":", ";")

            -- Some keywords may need special care.

            -- Now I assume that the reset keywords are MediaTek private,
            -- and they all match the MediaTek's keywords.
            -- So, I simply dump the "k=v" pairs.
            else
                devscfg[k] = v
            end
        end

        local sku_test = find_sku_info(BD_CountryCode, SKU_REGION_NORMAL)
        if sku_test then
            devscfg.CountryRegion = sku_test["region"]
            devscfg.CountryRegionABand = sku_test["aregion"]
            devscfg.SKUenable = sku_test["SKUenable"]

            if BD_CountryCode == "EU" or BD_CountryCode == "UK" then
                devscfg.SkuTableIdx = 1
            elseif BD_CountryCode == "US" then
                devscfg.SkuTableIdx = 2
            elseif BD_CountryCode == "ID" then
                devscfg.SkuTableIdx = 3
            else
                devscfg.SkuTableIdx = 0
            end

            --Special power customization
            local skuidx = UCI:get("power_specialized", BD_CountryCode, NV_CountryCode)
            if tonumber(skuidx) ~= nil then
                devscfg.SkuTableIdx = tonumber(skuidx)
            end
        end

        if devscfg.SKUenable == "1" and devscfg.MUTxRxEnable == 1 then
            devscfg.BFBACKOFFenable = 1
        else
            devscfg.BFBACKOFFenable = 0
        end
        --if not (devscfg.HT_BW == 1 and devscfg.VHT_BW == 0) then
        --    devscfg.HT_BSSCoexistence = 0
        --end
        -- for k,v in __spairs(devscfg) do print(k.."="..v) end

        merge_profile(datcfg, vifscfg)
        merge_profile(datcfg, devscfg)
    break end end

    os.execute("mkdir -p /tmp/mtk/wifi/")
    local _,_,datbak = datfile:find("([%w%.]+%.dat)")
    if datbak then
        datbak = datbak..".bak"
        os.execute("cp "..datfile.." /tmp/mtk/wifi/"..datbak)
    end

    save_profile(datcfg, (not testmode) and datfile)

end


--[[
    A basic imitation of posix "getopt".
]]
function getopt(argv, fmt)
    local tab = {}
    local i = 1

    while i <= #argv do
        local arg = argv[i]
        local m = arg:match("-(%w+)")
        if m then
            if fmt:find(m..":") then
                tab[m] = argv[i+1]
                i = i + 1
            elseif fmt:find(m) then
                tab[m] = true
            else
                error("invalid option "..m)
            end
        else
            table.insert(tab, arg)
        end
        i = i + 1
    end

    return tab
end



----------------------------  TIME TO GO ----------------------------
----------------------------  TIME TO GO ----------------------------
----------------------------  TIME TO GO ----------------------------
----------------------------  TIME TO GO ----------------------------
----------------------------  TIME TO GO ----------------------------

local opts = getopt(arg, "l:u:d:hf:tx")
local datfile = opts["f"]
local devname = opts["d"]
if opts["l"] then l1profile = opts["l"] end
if opts["u"] then ucifile = opts["u"] end
if opts["t"] then testmode = true end
if opts["x"] then iwpriv_mode = true end

-- help message
if opts["h"] then
    print([[

This tool translates between openwrt uci configuration and MediaTek WiFi profile.
It can be used in 4 ways as below:

    uci2dat [options] [datfile]
    dat2uci [options] [datfile]
    datdiff <old-dat> <new-dat>
    l1prof  [-l l1profile]

Options:
    -h   display help message.
    -t   test mode, will not modify target files but dump result to stdout.
    -x   iwpriv mode, "datdiff" will generate "iwpriv" commands according to diff result.
    -l   specify l1profile path if available. ("/etc/wireless/l1profile")
    -u   specify uci configuration path. ("/etc/config/wireless")
    -f   specify wifi profile path. ("/etc/wireless/mt76*/mt76*.dat")
    -d   specify device name. It should match the "device" value in both uci configuration
         and l1profile.

Examples: UCI ==> DAT

    1. if l1profile is present.
    uci2dat -u /etc/config/wireless -l /etc/wireless/l1profile.dat

    2. without l1prfile, you need to specify the device name and its profile path.
    uci2dat -u /etc/config/wireless -d mt7628 -f /etc/wireless/mt7628/mt7628.dat

Examples: DAT ==> UCI

    1. if l1profile is present.
    dat2uci -l /etc/wireless/l1profile.dat -u /etc/config/wireless

    2. without l1prfile, you need to specify device and its profile path.
    dat2uci -d mt7628 -u /etc/config/wireless -f /etc/wireless/mt7628/mt7628.dat

    3. without "-u", the result will be print to stdout.
    dat2uci -l /etc/wireless/l1profile.dat
    dat2uci -d mt7613 -f /etc/wireless/mt7613/mt7613.dat

Examples: Dump DAT difference
    1. for human readable result
    datdiff /etc/wireless/mt7615.1.2G.dat.bak /etc/wireless/mt7615.1.2G.dat

    2. translate into executable "iwpriv" commands
    datdiff -x /etc/wireless/mt7615.1.2G.dat.bak /etc/wireless/mt7615.1.2G.dat

Examples: Dump l1profile content
    1. dump default l1profile "/etc/wireless/l1profile.dat"
    l1prof

    2. specify l1profile path
    l1prof -l /tmp/l1profile.dat

]])
    return
end



if arg[0]:match("uci2dat") then
    if datfile then
        uci2dat(ucifile, datfile, devname)
    else
        -- try l1profile
        local l1dat = load_l1profile(l1profile)
        for i, dev in ipairs(l1dat) do
            uci2dat(ucifile, dev.profile_path, dev.devname)
        end
    end
else
    print("Illegal alias!", arg[0])
end
